---
title: "TS"
author: "Kate"
date: '26 февраля 2019 г '
output: 
   html_document:
       toc: true
       theme: united
       toc_float: true
---

```{r setup, include=FALSE}
library(ggplot2)
library(zoo)
library(dplyr)
library(stats)
library(mFilter)
library(Sim.DiffProc)
library(colorednoise)
library(forecast)
```


# Данные: Ежемесячное количество осадков (мм), Филадельфия, 1850-1950.

from: https://datamarket.com/data/set/22v5/monthly-precipitation-mm-philadelphia-1820-1950#!ds=22v5&display=line

Посмотрим на данные: 

```{r}
data1 <- read.table('D:/Учеба/1 КУРС МАГИСТРАТУРА/Голяндина практика/monthly-precipitation-mm-philade.csv', sep=";", header = TRUE)

head(data1)

```


Данные даны за каждый месяц с 50 года по 50. 1212 наблюдений.

# ts в R, как задается временной ряд и временная шкала.

Функция ts используется для создания объектов временных рядов.

as.ts и is.ts приводят объект к временному ряду и проверяют, является ли объект временным рядом.

## Использование:

ts(data = NA, start = 1, end = numeric(), frequency = 1, deltat = 1, ts.eps = getOption("ts.eps"), class = , names = )
   
as.ts(x, ...)

is.ts(x)

## Аргументы:

data ---	вектор или матрица наблюдаемых значений временного ряда.

start	--- время первого наблюдения. Либо одно число, либо вектор из двух целых чисел, которые задают натуральную единицу времени и количество отсчетов (на основе 1) в единицу времени.

end	--- время последнего наблюдения, указанное так же, как и начало.

frequency	--- количество наблюдений за единицу времени.

deltat --- доля периода выборки между последовательными наблюдениями; например, 1/12 для ежемесячных данных. Должна быть указана только либо частота либо deltat.

ts.eps --- допуск сравнения временных рядов. Частоты считаются равными, если их абсолютная разница меньше, чем ts.eps.

class	--- класс, который будет передан результату, или none, если NULL или "none". По умолчанию «ts» для одной серии, c («mts», «ts», «matrix») для нескольких серий.

names	--- символьный вектор имен для ряда в нескольких рядах: по умолчанию это имена столбцов данных, или Series 1, Series 2, ....

x	--- произвольный объект R.

...	--- аргументы, передаваемые в методы (не используются для метода по умолчанию).

## Храним данные в объекте типа "временной ряд".

```{r}
data <- data1[,2]
dataTS <- ts(data,  frequency=12) #такая частота, т.к. данные по месяцам собраны.
```



# График данные ряда.


```{r}
plot.ts(dataTS)
```


# Периодограмма.

```{r}
SpecPGram <- spec.pgram(dataTS, detrend="True",  log = "no",  plot = TRUE)
```

тут по оси X: 0/12, 1/12, 2/12 и т.д. Получили, что скорее всего период нашего ряда = 12, что довольно логично. и много шума здесь.


# Автокорреляции

from: http://r-statistics.co/Time-Series-Analysis-With-R.html

Автокорреляция --- это корреляция временного ряда с лагом самого себя. Это важный показатель, потому что,
Он показывает, влияют ли предыдущие состояния (запаздывающие наблюдения) временного ряда на текущее состояние. На диаграмме автокорреляции, если автокорреляция пересекает пунктирную синюю линию, это означает, что конкретное запаздывание значительно коррелирует с текущим рядом. Например, на диаграмме автокорреляции AirPassengers- в верхнем левом графике (ниже), существует значительная автокорреляция для всех лагов, показанных на оси x.

Обычно используется для определения того, является ли временной ряд стационарным или нет. У стационарного временного ряда автокорреляция довольно быстро падает до нуля, но для нестационарного ряда она постепенно падает.


```{r}
acfRes <- acf(dataTS)
```


У нас получается, что тренда нет.



# Белый и красный шум:

## Периодограмма белого шума:

```{r}
white <- rnorm(1000)
spec.pgram(white,  log = "no",  plot = TRUE)
```

Сглаженная периодограмма:

```{r}
spec.pgram(white, spans = c(50,50),  log = "no")
```

нанесем также две периодограммы на один график для наглядности:

Черным - периодограмма шума, красным --- сглаженная периодограмма

```{r}
spec.pgram(white,  log = "no",  plot = TRUE)
spec.pgram(white, spans = c(50,50),  log = "no",col="red", add=TRUE) 
legend(0.25,5.5,c("Периодограмма шума", "Сглаженная периодограмма"), col=c("black", "red"),lty=c(1,1))
```

Смотрим на качество сглаживания как на качество выделения тренда, и здесь при ширине окна 50, получили гладкий, медленно меняющийся результат.



## Периодограмма красного шума:


```{r}
red <- colored_noise(1000, 0, 1, 0.5)
spec.pgram(red,  log = "no",  plot = TRUE)
```

Сглаженная периодограмма:

```{r}
spec.pgram(red, spans = c(50,50),  log = "no",  plot = TRUE)
```

нанесем также две периодограммы на один график для наглядности:

Черным - периодограмма шума, красным --- сглаженная периодограмма

```{r}
spec.pgram(red,  log = "no",  plot = TRUE)
spec.pgram(red, spans = c(50,50),  log = "no",col="red", add=TRUE) 
legend(0.25,10.5,c("Периодограмма шума", "Сглаженная периодограмма"), col=c("black", "red"),lty=c(1,1))
```

Смотрим на качество сглаживания как на качество выделения тренда, и здесь при ширине окна 50, получили гладкий, медленно меняющийся результат.

# Растекание частоты в периодограмме. Подправка длины ряда для ее устранения.

Было на паре: Пример:

$x_n=Acos(2\pi wn+\psi)$,  $n=1,...,N$

а) $w=\frac{k}{N}$ => попадаем в решетку
б) $w\neq\frac{k}{N}$ => cos не ортогонален ни одному вектору из базиса.

Промоделируем такой пример: (cos с частотой 2/7 и длина ряда 20)

```{r}
xn <- cos(2*pi*(2/7)*c(1:20))
spec.pgram(xn, log = "no", detrend = FALSE, fast = FALSE, pad = TRUE, taper = 0)
```


Что делать в таком случае?
2 варианта:
1) ряд урезается
2) дополняется нулями

Добавим в ряд 1 ноль: (так как нам надо, чтоб $\frac{2N}{7}$ нацело)

```{r}
xn <- c(xn, 0)
spec.pgram(xn, log = "no", detrend = FALSE, fast = FALSE, pad = TRUE, taper = 0)
```

# Выделение тренда у ряда с сезонностью (выбор длины окна в скользящем среднем).

Для выделения тренда у ряда с сезонностью с помощью скользящего среднего нужно взять окно кратное периоду. (равное или кратное, чем больше окно, тем более гладкий результат)

Функция скользящего среднего: ma()

```{r}
plot(dataTS, main = "Тренд у ряда с сезонностью с окном = 120")
ma120 <- ma(dataTS, 120)
lines(ma120, col = "red")
```

Здесь концы не покрыты, далее (в пункте "фильтр скользящего среднего") будет использоваться другая функция, которая покроет концы.


Для сравнения посмотрим на дургие варианты ширины окна:

```{r}
plot(dataTS, main = "Тренд у ряда с сезонностью с окном = 12")
ma12 <- ma(dataTS, 12)
lines(ma12, col = "red")
```

```{r}
plot(dataTS, main = "Тренд у ряда с сезонностью с окном = 36")
ma36 <- ma(dataTS, 36)
lines(ma36, col = "red")
```

Вывод: чем больше длина окна, тем более гладкий результат мы получаем.


# Периодограмма остатка после выделения тренда 

```{r}
OST <- dataTS-na.omit(ma120)
spec.pgram(OST, log="no",detrend="True", main="Периодограмма остатка",  plot = TRUE)
```

Здесь у нас частота 12 практически не снялась. 

Посмотрим периодограмму остатка при ширине окна 240:


```{r}
plot(dataTS, main = "Тренд у ряда с сезонностью с окном = 120")
ma240 <- rollapply(dataTS, width=240, FUN=mean)
lines(ma240, col = "red")
OST <- dataTS-ma240
spec.pgram(OST, log="no",detrend="True", main="Периодограмма остатка",  plot = TRUE)
```

Здесь видно, что частота 12 уже гораздо сильнее снялась. 




# Фильтр скользящего среднего:

Здесь му будем снова использовать скользящее среднее, но уже с другой функцией, чтобы "покрыть хвосты"

Пользуюсь встроенной функцией filter: 

### Использование:

filter(x, filter, method = c("convolution", "recursive"), sides = 2, circular = FALSE, init)

### Аргументы:

x	 --- одномерный или многомерный временной ряд.

filter --- вектор коэффициентов фильтра в обратном порядке времени.

method --- Либо "свертка" или "рекурсивный" (и может быть сокращено). Если для «свертки» используется скользящее среднее, то для «рекурсивной» используется авторегрессия.

sides --- только для фильтров свертки. Если сторон = 1, коэффициенты фильтра только для прошлых значений; если стороны = 2, они центрированы вокруг запаздывания 0. В этом случае длина фильтра должна быть нечетной, но если она четная, больше фильтра направлено вперед, чем назад.

circular --- только для фильтров свертки. Если TRUE, оберните фильтр вокруг концов ряда, в противном случае предположите, что внешние значения отсутствуют (NA).

init --- только для рекурсивных фильтров. Задает начальные значения временного ряда непосредственно перед начальным значением в обратном порядке времени. По умолчанию это набор нулей.


## Зависимость результата от длины окна.

У меня поставлено CIRCULAR=TRUE, т.е. мы обрабытываем вместе с концами. Длина нашего ряда (1212) кратна периоду, так что мы можем использовать данную функцию.


У нашего ряда период 12. Рассмотрим окна с шириной 12, 120, 240. 


```{r}
filt1 <- stats::filter(dataTS, rep(1/12,12), method="convolution", sides=2, circular=TRUE)
plot(dataTS, type="l", col="black", main = "Фильтрация с шириной окна 12")
lines(filt1, col="red")
```

```{r}
filt1 <- stats::filter(dataTS, rep(1/120,120), method="convolution", sides=2, circular=TRUE)
plot(dataTS, type="l", col="black", main = "Фильтрация с шириной окна 120")
lines(filt1, col="red")
```


```{r}
filt1 <- stats::filter(dataTS, rep(1/240,240), method="convolution", sides=2, circular=TRUE)
plot(dataTS, type="l", col="black", main = "Фильтрация с шириной окна 240")
lines(filt1, col="red")
```


У нас "хвосты" покрыты. 

Вопрос: как отработал фильтр в зависимости от ширины окна?

При выборе бОльшей ширина окна мы получали бОльшую гладкость.



# Смотрим на АЧХ фильтров:

Амплитудно-частотная характеристика (АЧХ) — зависимость амплитуды выходного сигнала некоторой системы от частоты её входного гармонического сигнала. Иногда эту характеристику называют «частотным откликом системы» (frequency response).

$A_\text{ф}(w)=|H_\text{ф}(e^{i2\pi w})|$ , где $H_\text{ф}(z)=\sum_ih_iz^{-i}$ --- передаточная функция


```{r}
afc <- function(filter, omega) {
    k <- seq_along(filter) - 1
    h <- function(o) sum(rev(filter) * exp(-k*1i * o)) 
    abs(sapply(omega, h))
}

freq <- seq(0, pi, 0.001)
filt <- rep(1/12, 12)
omega <- freq/2/pi
plot(afc(filt, freq) ~ omega, type = "l", xaxt="n", main = "АЧХ фильтра скользящего среднего для окна = 12")
axis(1, at = c( 0, 1/12, 2/12, 3/12, 4/12, 5/12, 1/2), labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)
```


Частоты 1/12, 2/12, 3/12 и т.д. этот фильтр превращает в 0. Он не сильно снимает высокие частоты.


```{r}
freq <- seq(0, pi, 0.001)
filt <- rep(1/120, 120)
omega <- freq/2/pi
plot(afc(filt, freq) ~ omega, type = "l", xaxt="n", main = "АЧХ фильтра скользящего среднего для окна = 120")
axis(1, at = c( 0, 1/12, 2/12, 3/12, 4/12, 5/12, 1/2), labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)
```

```{r}
freq <- seq(0, pi, 0.001)
filt <- rep(1/240, 240)
omega <- freq/2/pi
plot(afc(filt, freq) ~ omega, type = "l", xaxt="n", main = "АЧХ фильтра скользящего среднего для окна = 120")
axis(1, at = c( 0, 1/12, 2/12, 3/12, 4/12, 5/12, 1/2), labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)
```


Т.е. при увеличении ширины окна фильтр начинает сильнее снимать высокие частоты.

# Аддитивная и мультипликативная модель

По нашему ряду на самом деле очень сложно понять, даже нельзя понять, аддитивная или мультипликативная модель.

Почему?

В мультипликативной модели размер колебаний (даже не только шум, а шум+периодичность) зависит от величины тренда. 

В аддитивной модели значение тренда не имеет значения, колебания всегда примерно одинаковые.

Для того, чтобы понять, что модель мультипликативная, нам нужно, чтобы у тренда были разные значения. То есть чтобы он где-то был больше, где-то меньше. Тогда мы сможем увидеть, что в тех местах, где тренд больше, больше и колебания. Но в нашем случае тренд почти что константа (+-) и значение тренда всегда почти одинаковое. Поэтому нам не отчего оттолкнуться.

# Фильтр скользящей медианы.

Что тут хорошо? --- робастная оценка

Встроенная функция: runmed


## Использование:

runmed(x, k, endrule = c("median","keep","constant"), algorithm=NULL, print.level=0)

## Аргументы:

x	  --- числовой вектор, «зависимая» переменная для сглаживания.

k	  --- целочисленная ширина медианного окна; должно быть странно Turlach имел значение по умолчанию k <- 1 + 2 * мин ((n-1)% /% 2, потолок (0,1 * n)). Используйте k = 3 для «минимального» надежного сглаживания, устраняя изолированные выбросы.

endrule	 --- символьная строка, указывающая, как должны обрабатываться значения в начале и конце (данных). Может быть сокращено. Возможные значения:
      "keep"  --- сохраняет первое и последнее значения k2 на обоих концах, где k2 - это половина полосы пропускания k2 = k% /% 2, т. е. y [j] = x [j] для j = 1,…, k2 и (n-k2 +1),…, n;
      "constant"  ---  копирует медиану (y [1: k2]) в первые значения и аналогично для последних, делая сглаженные концы постоянными;
      "median"  ---  по умолчанию сглаживает концы, используя симметричные медианы впоследствии меньшей пропускной способности, но для самого первого и последнего значения, где применяется надежное правило конечной точки. (т.е. для хвостов медиана будет с меньшим окном , но первое и последнее значения останутся теми, что и есть)

algorithm	 --- символьная строка (частично совпадающая с «Turlach» или «Stuetzle») или значение по умолчанию NULL, указывающее, какой алгоритм должен применяться. Выбор по умолчанию зависит от n = length (x) и k, где «Turlach» будет использоваться для более крупных задач.

print.level	 --- целое число, указывающее на многословность алгоритма; должны редко меняться средними пользователями.


## Применение скользящей медианы:

Возьмем ширину окна: 120
Способ обрабатывания концов : median  

Но нам необходимо брать ширину окна нечетной, чтоб точно определить середину.
Поэтому, ширина окна 121:

```{r}
runmed121 <- stats::runmed(dataTS, 121, endrule="median")
filt1 <- stats::filter(dataTS, rep(1/120,120), method="convolution", sides=2, circular=TRUE)

plot(dataTS[1:1212],col="black",type="l")
lines(filt1[1:1212] ,col="red")
lines((runmed121[1:1212]),col="blue")
legend(60,410,c("DataTS", "Скользящее среднее","Скользящая медиана"), col=c("black","red","blue"),lty=c(1,1))
```



Как и говорилось на паре про мои данные, скользящая медиана лежит немного ниже скользящего среднего. (хотя есть и не такие участки)


# Фильтр Hodrik-Prescott

$min_{\{s_i\}}(\sum_{i=1}^N(x_i-s_i)^2+\lambda\sum_{i=2}^{N-1}((s_{i+1}-s_i)-(s_i-s_{i-1}))^2)$


1е слагаемое: квадраты отклонений от исходного ряда

2е слагаемое: вторая производная, мы ее заменяем разностью разностей.


Рекомендовано использовать $\lambda=129600$.
Вообще этот параметр отвечает за гладкость функции. 

Встроенная функция: hpfilter

## Использование:

hpfilter(x,freq=NULL,type=c("lambda","frequency"),drift=FALSE)

## Аргументы:

x	 ---  регулярный временной ряд.

type	 ---  символ, обозначающий тип фильтра: «лямбда», для фильтра, который использует параметр штрафа сглаживания фильтра Ходрика-Прескотта (по умолчанию). Эти типы связаны: $\lambda$ = (2*sin(pi/frequency))^{-4}.

freq	 ---  целое число, если type = "lambda", то freq - это параметр сглаживания (lambda) фильтра Ходрика-Прескотта, если type = "Frequency", то freq - частота среза фильтра Ходрика-Прескотта.

drift	 ---  логический, ЛОЖЬ, если нет дрейфа во временных рядах (по умолчанию), ИСТИНА, если дрейф во временных рядах.


## Применение фильтра Hodrik-Prescott:

```{r}
DataHP1 <- hpfilter(dataTS, freq=129600, type="lambda")

plot(dataTS, main="Применение фильтра Hodrik-Prescott")
lines(DataHP1$trend, col="red")
```

Нанесем на график еще выделение тренда с помощью скользящего среднего с шириной окна 120 для того, чтобы сравнить гладкость результата:

```{r}
plot(dataTS, main="Сравнение гладкости с фильтром скользящего среднего и Hodrik-Prescott")
lines(DataHP1$trend, col="red")
lines(filt1 ,col="blue")
legend(55,410,c("DataTS", "Скользящее среднее (120)","Hodrik-Prescott(129600)"), col=c("black", "blue", "red"),lty=c(1,1))
```

Результат получился более гладким, чем при скользящей медиане.

Если параметр $\lambda$ отвечает за гладкость, что будет если взять его еще больше? например, 200000

```{r}
DataHP2 <- hpfilter(dataTS, freq=200000, type="lambda")

plot(dataTS, main="Применение фильтра Hodrik-Prescott")
lines(DataHP2$trend, col="red")
```


Разница не большая. А если взять маленькое $\lambda$ ?

```{r}
DataHP3 <- hpfilter(dataTS, freq=10000, type="lambda")

plot(dataTS, main="Применение фильтра Hodrik-Prescott")
lines(DataHP3$trend, col="red")
```


Здесь уже довольно хорошо видно, что вторая производная стала больше, отчего более сильные изменения получились.


# Полиномиальная регрессия

## Линейная регрессия

```{r}
lm1 <- lm(dataTS ~ c(1:1212))

plot(dataTS[1:1212], type="l")
lines(lm1$fitted.values[1:1212], col = "red")
```




## Полиномиальная регрессия

```{r}
model3 <- lm(dataTS ~ poly(c(1:1212),11))

plot(dataTS[1:1212], type="l")
lines(model3$fitted.values[1:1212], col = "red")
```

Вообще, пробовалось брать разные степени полиномов, уже после 11 особо ничего не меняется. Т.е. скорее всего у нас тут все пытается выделить более-менее константный тренд


# LOESS (локальная регрессия)

Встроенная функция: loess

## Использование:

loess(formula, data, weights, subset, na.action, model = FALSE,
      span = 0.75, enp.target, degree = 2,
      parametric = FALSE, drop.square = FALSE, normalize = TRUE,
      family = c("gaussian", "symmetric"),
      method = c("loess", "model.frame"),
      control = loess.control(...), ...)

## Аргументы:

formula	 --- формула, указывающая числовой ответ и от одного до четырех числовых предикторов (лучше всего указывать через взаимодействие, но также можно указывать дополнительно). При необходимости будет приведен к формуле.

data	 --- необязательный фрейм данных, список или окружение (или объект, приводимый as.data.frame в фрейм данных), содержащий переменные в модели. Если данные не найдены, переменные берутся из среды (формулы), обычно из среды, из которой вызывается лесс.

weights	 ---  дополнительные веса для каждого случая.

subset	---   необязательная спецификация подмножества данных, которые будут использоваться.

na.action	 ---  действие с отсутствующими значениями в ответе или предикторах. По умолчанию используется getOption ("na.action").

model	 ---  должен ли быть возвращен фрейм модели?

span	 ---  параметр ??, который контролирует степень сглаживания.Размер окрестности контролируется ?? (устанавливается span или enp.target). Для ?? <1 окрестность включает в себя пропорцию ?? точек, и они имеют трикубический вес (пропорциональный (1 - (dist / maxdist) ^ 3) ^ 3). При ??> 1 используются все точки, причем «максимальное расстояние» предполагается равным ?? ^ (1 / p), умноженным на фактическое максимальное расстояние для p объясняющих переменных.

enp.target	 ---  альтернативный способ указать диапазон, как примерное эквивалентное количество используемых параметров.

degree	 ---  степень используемых многочленов, обычно 1 или 2. (Степень 0 также допускается, но см. «Примечание».)

parametric	 ---  должны ли какие-либо термины соответствовать глобально, а не локально? Термины могут быть указаны по имени, номеру или в виде логического вектора той же длины, что и число предикторов.

drop.square	 ---  для совпадений с более чем одним предиктором и степенью = 2 следует ли отбрасывать квадратный член для определенных предикторов? Условия указаны так же, как и для параметрических.

normalize	 ---  следует ли нормализовать предикторы к общей шкале, если их больше одного? Нормализация используется для установки стандартного отклонения с усечением 10% на единицу. Установите значение false для пространственных координатных предикторов и других, о которых известно, что они находятся в общем масштабе.

family	 ---  если «гауссовская» аппроксимация выполняется методом наименьших квадратов, а если «симметричная», то с би-весовой функцией Тьюки используется повторно нисходящая оценка М. Может быть сокращено.

method	 ---  установить модель или просто извлечь рамку модели. Может быть сокращено.

control	 ---  параметры управления: см. loess.control.

...	 ---   параметры управления также могут быть предоставлены напрямую (если управление не указано).


```{r}
dataLOESS <- loess(dataTS ~ c(1:1212), data = dataTS, span=0.2)

plot(dataTS[1:1212], type="l")
lines(predict(dataLOESS)[1:1212], col = "red")
```


Сравним это выделение тренда с другими нанеся на один график:

```{r}
plot(dataTS[1:1212], type="l", main="Сравнение")
lines(DataHP1$trend[1:1212], col="red")
lines(filt1[1:1212] ,col="blue")
lines(predict(dataLOESS)[1:1212], col = "green")
legend(640,410,c("DataTS", "Скользящее среднее (120)","Hodrik-Prescott(129600)", "LOESS (0.2)"), col=c("black", "blue", "red", "green"),lty=c(1,1))
```
















































