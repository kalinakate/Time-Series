---
title: "TSDZPart2"
author: "Kate Bakshinskaia"
date: '4 апреля 2019 г '
output: 
   html_document:
       toc: true
       theme: united
       toc_float: true
---

```{r setup, include=FALSE}
library(ggplot2)
library(zoo)
library(dplyr)
library(stats)
library(mFilter)
library(Sim.DiffProc)
library(Rssa)
library(readxl)
library(graphics)
library(normwhn.test)
```


# SSA на модельных данных (ряды с номерами 1 и 7)



```{r}
data1 <- read_excel('D:/Учеба/1 КУРС МАГИСТРАТУРА/Голяндина практика/stud2005.xls')
data1 <- data1[,c(1,7)]
data1
```

## Ряд 1

```{r}
Mod1 <- data1[,1]
plot.ts(Mod1)
```

Периодограмма:

```{r}
spec.pgram(Mod1, detrend="TRUE",  log = "no",  plot = TRUE)
```

пик в 0.1 и явный в 0.05


ВФДЕЛЕНИЕ ТРЕНДА


```{r}
s <- ssa(Mod1)
plot(s) #с.ч.
```



Посмотрим на график собственных векторов:

```{r}
plot(s, type = "vectors")
```

2 медленно меняющие состовляющие 1 и 2я


```{r}
trendrec <- reconstruct(s, group = list(trend = c(1,2)))

plot(ts(Mod1), col="black")
lines(trendrec$trend ,col="red")
```

Супер!
Теперь остаток после тренда разделим на периодическую составляющую и шум.



ВЫДЕЛЕНИЕ ПЕРИОДИЧНОСТИ

```{r}
plot(s, type = "paired")
```

Посмотрев на эти графики, к сезонности попробуем отнести 3:4, 5:6, 7:8


```{r}
pe <- parestimate(s, groups = list(3:4, 5:6, 7:8))
pe
```

Mатрицa w-корреляций:

```{r}
sesrec <- reconstruct(s, groups = list( season =c(3:4, 5:6, 7:8)))

plot(wcor(s, groups = c(3:4, 5:6, 7:8)))
```



Шум:

```{r}
OST <- Mod1 - trendrec$trend - sesrec$season
plot(ts(OST))
```

Анализ шума:

Периодограмма остатка:

```{r}
spec.pgram(OST, detrend="TRUE",  log = "no",  plot = TRUE)
```

График автокорреляций:

```{r}
acf(OST, plot = TRUE)
```

Видим, что перед нами действительно белый шум. Значит, все хорошо, мы все правильно выделили.


```{r}
TrSe <- trendrec$trend + sesrec$season

plot(ts(Mod1), col="black")
lines(TrSe ,col="red")
```



## Ряд 7

```{r}
Mod2 <- na.omit(data1[,2])
plot.ts(Mod2)
```


```{r}
spec.pgram(Mod2, detrend="TRUE",  log = "no",  plot = TRUE)
```

пик в 0.1 и явный в 0.05, а еще в других частях много...


ВФДЕЛЕНИЕ ТРЕНДА

```{r}
s2 <- ssa(Mod2)
plot(s2) # с.ч.
```


```{r}
plot(s2, type = "vectors")
```


2 медленно меняющие состовляющие 1 и 2я, отнесем их к тренду:

```{r}
trendrec2 <- reconstruct(s2, group = list(trend = c(1,2)))

plot(ts(Mod2), col="black")
lines(trendrec2$trend ,col="red")
```


ВЫДЕЛЕНИЕ ПЕРИОДИЧНОСТИ

```{r}
plot(s2, type = "paired")
```

Посмотрев на эти графики, к сезонности попробуем отнести только 3:4 и посмотрим на остаток:


```{r}
pe <- parestimate(s2, groups = list(3:4))
pe
```

Mатрицa w-корреляций:

```{r}
sesrec2 <- reconstruct(s2, groups = list( season =c(3:4)))

plot(wcor(s2))
```



Шум:

```{r}
OST2 <- Mod2 - trendrec2$trend - sesrec2$season
plot(ts(OST))
```

Анализ шума:

Периодограмма остатка:

```{r}
spec.pgram(OST2, detrend="TRUE",  log = "no",  plot = TRUE)
```

График автокорреляций:

```{r}
acf(OST2, plot = TRUE)
```


Видим, что перед нами действительно белый шум. Значит, все хорошо, мы все правильно выделили и одно компоненты сезонности достаточно.


```{r}
TrSe2 <- trendrec2$trend + sesrec2$season

plot(ts(Mod2), col="black")
lines(TrSe2 ,col="red")
```


# SSA на реальных данных

Данные: Среднемесячная температура, 1907 - 1972 гг.

from: https://datamarket.com/data/set/22o4/mean-monthly-temperature-1907-1972#!ds=22o4&display=line


```{r}
data1 <- read.table('D:/Учеба/1 КУРС МАГИСТРАТУРА/Голяндина практика/mean-monthly-temperature-1907-19.csv', sep=";", header = TRUE)
head(data1)
```

График данные ряда

```{r}
data <- data1[,2]
dataTS <- ts(data,  frequency=12) #такая частота, т.к. данные по месяцам собраны.
plot.ts(dataTS)
```

Периодограмма

```{r}
SpecPGram <- spec.pgram(dataTS, detrend="True",  log = "no",  plot = TRUE)
```

Явный пик в 12, так же можно заметить пики в 6, 4 (мы увидем далее как они проявляются)

# decompose

Будем использовать встроенную функцию decompose().

## Использование:

decompose(x, type = c("additive", "multiplicative"), filter = NULL)

## Аргументы:


x	 --- Временной ряд.

type	 ---  Тип сезонного компонента. Может быть сокращено.

filter	 ---  Вектор коэффициентов фильтра в обратном порядке времени (как для коэффициентов AR или MA), используется для фильтрации сезонной составляющей. Если NULL, скользящее среднее с симметричным окном выполняется.


```{r}
dec <- stats::decompose(dataTS, "additive")
plot(dec)
```

Нарисуем тренд на графике данные ряда

```{r}
plot(dataTS, col="black")
lines(dec$trend ,col="red")
```


Выделенный шум

```{r}
plot(dec$random, col="black")
```

Периодограмма шума

```{r}
SpecPGram <- spec.pgram(na.omit(dec$random), detrend="True",  log = "no",  plot = TRUE)
```


На этой периодограмме вырезан кусок высоких частот. Очевидно, что он вырезан частотным образом в каком-то смысле. Туда, наверное, и тренд попал, зодно и все частоты шума туда же. С такой периодограммой, вообще говоря, белый шум тут не может быть, т.к. у белого шума все частоты должны быть


```{r}
acf(na.omit(dec$random))
```

По графику автокорреляций видно, что из шума забрали низкие частоты.




# stl

Будем использовать встроенную функцию stl().

## Использование:

stl(x, s.window, s.degree = 0,
    t.window = NULL, t.degree = 1,
    l.window = nextodd(period), l.degree = t.degree,
    s.jump = ceiling(s.window/10),
    t.jump = ceiling(t.window/10),
    l.jump = ceiling(l.window/10),
    robust = FALSE,
    inner = if(robust)  1 else 2,
    outer = if(robust) 15 else 0,
    na.action = na.fail)

## Аргументы:

x	 ---  одномерный временной ряд для разложения. Это должен быть объект класса "ts" с частотой больше единицы.

s.window	 ---  либо строка символов «периодический», либо интервал (в лагах) окна лесса для сезонного извлечения, который должен быть нечетным и не менее 7, согласно Cleveland et al. Это не имеет значения по умолчанию. (размер подрядов, по неделям, месяцам и т.д.)

s.degree	 ---   степень локально подогнанного полинома в сезонной экстракции. Должно быть ноль или один.

t.window	---  промежуток (в лагах) окна лесса для извлечения тренда, который должен быть нечетным. Если NULL, принимается значение по умолчанию, nextodd (потолок ((1,5 * период) / (1- (1,5 / с. Окно)))).

t.degree	---  степень локально подогнанного полинома в выделении трендов. Должно быть ноль или один.

l.window	---   диапазон (в лагах) окна лёсса фильтра нижних частот, используемого для каждой подсерии. По умолчанию используется наименьшее нечетное целое число, большее или равное частоте (x), что рекомендуется, поскольку оно предотвращает конкуренцию между трендом и сезонными компонентами. Если нечетное целое число, его заданное значение увеличивается до следующего нечетного.

l.degree	---   степень локально подогнанного полинома для фильтра нижних частот подсерии. Должно быть 0 или 1.

s.jump, t.jump, l.jump	 ---  целые числа, по крайней мере, один, чтобы увеличить скорость соответствующего сглаживателя. Линейная интерполяция происходит между каждым значением * .jumpth.

robust	---   логическое указание, будет ли использоваться надежный пример в процедуре лесса.

inner	---  целое число; количество «внутренних» (задних) итераций; обычно очень мало (2) итераций.

outer	 ---  целое число; количество «внешних» итераций устойчивости.

na.action	 ---  действие на пропущенные значения.


Вообще, эта функция должна бороться с проблемами в decompose (одинаковость периодов), т.к. благодаря внутреннему циклу, мы каждый раз находим новую оценку для сезонности. 

Сезонная составляющая определяется лессом, сглаживающим сезонные подсерии (ряды всех значений января, ...); если s.window = "periodic" --- сглаживание заменяется взятием среднего. Сезонные значения удаляются, а остаток сглаживается, чтобы найти тренд. s.window управляет тем, насколько быстро может изменяться сезонный компонент. Малые значения позволяют более быстрые изменения. Установка сезонного окна равной бесконечности эквивалентна принудительному тому, чтобы сезонный компонент был периодическим (т.е. Идентичным по годам). Если мы считаем, что сезонный паттерн постоянен во времени, нам следует установить для этого параметра большое значение, чтобы использовать все данные для анализа. Если же наоборот, сезонная модель быстро развивается, уменьшить этот параметр, чтобы использовать только последние данные, чтобы на анализ не влияли старые сезонные модели, которые больше не актуальны. 

В наших данных попробуем три варианта: s.window = "periodic" , 7, 37

## Вариант 1

```{r}
stl_ <- stl(dataTS, s.window="periodic", t.window=25)
plot(stl_)
```

Нарисуем тренд на графике данные ряда

```{r}
plot(dataTS, col="black")
lines(stl_$time.series[,2] ,col="red")
```


График шума:


```{r}
plot(stl_$time.series[,3], col="black", type="l")
```


```{r}
SpecPGram <- spec.pgram(stl_$time.series[,3], detrend="True",  log = "no",  plot = TRUE)
```

ситуация аналогична decompose.


```{r}
acf(stl_$time.series[,3])
```

По графику автокорреляций видно, что из шума забрали низкие частоты. 


## Вариант 2

```{r}
stl_ <- stl(dataTS, s.window=7, t.window=25)
plot(stl_)

plot(dataTS, col="black")
lines(stl_$time.series[,2] ,col="red")
```


График шума и периодограмма:


```{r}
plot(stl_$time.series[,3], col="black", type="l")
SpecPGram <- spec.pgram(stl_$time.series[,3], detrend="True",  log = "no",  plot = TRUE)
```


В данной ситуации получили много вырезанных кусков из шума. 


```{r}
acf(stl_$time.series[,3])
```

Этот вариант нам совсем не подходит.

## Вариант 3

```{r}
stl_ <- stl(dataTS, s.window=37, t.window=25)
plot(stl_)

plot(dataTS, col="black")
lines(stl_$time.series[,2] ,col="red")
```


График шума и периодограмма:


```{r}
plot(stl_$time.series[,3], col="black", type="l")
SpecPGram <- spec.pgram(stl_$time.series[,3], detrend="True",  log = "no",  plot = TRUE)
```


В данной ситуации получили много вырезанных кусков из шума. 


```{r}
acf(stl_$time.series[,3])
```

Здесь у нас ситуация аналогична варианту 1 и при увеличении параметра s.window уже далее ничего не меняется. Так что при параметрах s.window="periodic" (сглаживание взятием среднего) можно считать мы добились лучших результатов. 

# Не последоватеьный SSA

Наш тренд имеет простую форму, поэтому, нет необходимости использовать последовательный SSA. Применим SSA сразу с большой длиной окна равной половине ряда.

```{r}
s <- ssa(dataTS)
plot(s)
```

## Выделение тренда

Посмотрим на график собственных векторов:

```{r}
plot(s, type = "vectors")
```

1 медленно меняющаяся компонента --- 1я, отнесем ее к тренду:

```{r}
rec <- reconstruct(s, groups= list(trend = c(1)))
plot(dataTS, type="l")
lines(rec$trend, col="red")
```


Теперь остаток после тренда разделим на периодическую составляющую и шум.


## ВЫДЕЛЕНИЕ ПЕРИОДИЧНОСТИ

```{r}
plot(s, type = "paired")
```

Посмотрев на эти графики, к сезонности попробуем отнести 2:3, 4:5, 6:7 а также 10:11


```{r}
pe <- parestimate(s, groups = list(2:3, 4:5, 6:7, 10:11))
pe
```

Mатрицa w-корреляций:

```{r}
sesrec <- reconstruct(s, groups = list( season = c(2:3, 4:5, 6:7, 10:11)))
plot(wcor(s, groups = c(2:3, 4:5, 6:7, 10:11)))
```

Видим, компоненты хорошо отделимы друг от друга.

Шум:

```{r}
OST <- dataTS - rec$trend - sesrec$season
plot(ts(OST))
```

Анализ шума:

Периодограмма остатка:

```{r}
spec.pgram(OST, detrend="TRUE",  log = "no",  plot = TRUE)
```

График автокорреляций:

```{r}
acf(OST, plot = TRUE)
```

Видим в начале положительные корреляции, не белый шум.

Сравним выделенный сигнал с нашим рядом:

```{r}
TrSe <- rec$trend + sesrec$season

plot(dataTS, col="black")
lines(TrSe ,col="red")
```


У нас здесь нет проблемы со сложным трендом. Но здесь может быть проблема со сложной модуляцией синуса. Т.е. сезонность с криво меняющейся амплитудой. Сложность тренда --- это сам тренд. А если сложно меняется синус, то приходится для выделения этой сезонности брать небольшое L. Cложно в каком смысле --- оно локально простое, а на всем диапазоне сложное. Выход из этой ситуации --- взять небольшое L для выделения сезонности.

Для этого воспользуемся последовательным SSA. Для выделения тренда будем брать длину окна равную половине ряда, а для выделения сезонности небольшую длину окна кратную периоду --- 60.


# SSA Последовательный


## ТРЕНД

Для выделения тренда было приянто решение взять длину окна в половину ряда.

```{r}
s <- ssa(dataTS)
plot(s) # с.ч.
```
 

 Далее нужно выбрать компоненты, которые будут входить в тренд. Посмотрим на графики собственных векторов:

```{r}
plot(s, type = "vectors")
```

На первой картинке видно медленно меняющуюся составляющую.

```{r}
plot(s, type = "paired", plot.contrib = FALSE)
```


```{r}
plot(s,type="series")
```

К тренду отнесем первую компоненту.

Посмотрим на матрицу корреляций:

```{r}
cor <- wcor(s)
plot(cor)
```

Можно видеть, что первая компонента отделяется хорошо от других.

Посмотрим на выделенный нами тренд:

```{r}
rec <- reconstruct(s, groups = list(c(1)))
trend <- rec$F1
plot(dataTS, type = "l")
lines(trend, col = "red")
```


## Остаток после выделения тренда

Остаток это сезонность и шум. Глянем на периодограмму остатка:

```{r}
spec.pgram(dataTS-trend,log="no")
```

Можно сказать, что ничего не изменилось.

Применяем второй раз SSa с меньшей длиной окна:

```{r}
season <- dataTS-trend
sseason <- ssa(season, L = 60)
plot(sseason)
```

Снова смотрим все графики

```{r}
plot(sseason, type = "vectors")
```


```{r}
plot(sseason, type = "paired",idx=1:10)
```

По этому графику к сезонности можно отнести период 12 (пара 1-2), период 6 (пара 3-4) и период 4 (пара 7-8)

Матрица корреляций:

```{r}
plot(wcor(sseason))
```



```{r}
recSeason <- reconstruct(sseason, groups = list(c(1,2,3,4,7,8)))
trendSeason <- recSeason$F1
plot(season,type='l')
lines(trendSeason,type='l',col='red')
```


Получим шум:


```{r}
noise <- season-trendSeason
plot(noise,type='l')
```

Периодограмма:

```{r}
spec.pgram(dataTS-trendSeason,log="no")
```

По периодограмме видно, что вырезаны куски. Посмотрим на график автокорреляций:

```{r}
acf(na.omit(dataTS-trendSeason))
```

Не белый шум явно. И результат получился хуже, чем при непоследовательном SSA.

Получили, что в нашем ряде нет смысла применять последовательный SSA.


# Огибающие для шума

Построим огибающие для шума при непоследовательном SSA:

```{r}
plot(ts(OST))
sOST <- ssa(OST^2)
plot(sOST)
plot(s, type="vectors")
recOST <- reconstruct(sOST,group=list(trend=c(1)))
plot(OST^2)
lines(recOST$trend, col="red")
```

Итак:

```{r}
plot(OST)
lines(sqrt(recOST$trend), col="red")
lines(-sqrt(recOST$trend), col="red")
```

#Огибающие для гармоники

На занятии было: как найти огибающую A(n)?

$x_n = A(n)cos(2\pi wn+\phi)$

$y_n=2x_n^2=A^2(n)+A^2(n)cos(2(2\pi wn+\phi))$ --- первое слагаемое можно рассмотреть как тренд, второе --- моделируемый косинус.

Рассмотрим это на примере выделенной периодичности при непоследовательном SSA:

```{r}
plot.ts(sesrec$season)
#пусть y_n = 2*x_n^2
y_n <- 2*(sesrec$season^2)
sy_n <- ssa(y_n)
plot(sy_n, type="vectors")
```


```{r}
recy_n <- reconstruct(sy_n, groups = list(trend=c(1)))
plot(y_n)
lines(recy_n$trend, col="red")
```


```{r}
plot(sesrec$season)
lines(sqrt(recy_n$trend), col="red")
lines(-sqrt(recy_n$trend), col="red")
```


Получили огибающие для гармоники.







